1.DÜĞÜM (NODE) OLUŞTURMA VE TEMEL KAVRAMLAR

1.1 PAKET OLUŞTURMA VE YAPILANDIRMA
----------------------------------
ROS 2'de Python tabanlı bir paket oluşturmak için standart komut yapısı:

    ros2 pkg create simple_py_pkg --build-type ament_python --dependencies rclpy

- --build-type ament_python: Paketin Python ile derleneceğini belirtir.
- --dependencies rclpy: rclpy (ROS Client Library for Python) kütüphanesini bağımlılık olarak ekler.

Önemli Dosyalar:
- setup.py & package.xml: Paket hakkındaki bilgileri (metadata), bağımlılıkları ve kodun çalıştırılması için gereken giriş noktalarını (entry points) içerir.
- setuptools: Python paketlerinin dağıtımı için gereklidir.
  Kontrol komutu: pip3 list | grep setuptools

1.2. NODE (DÜĞÜM) NEDİR?
----------------------
Her bir Node (düğüm), robotik sistemde tek bir görevden sorumludur.

- İşlevi: Motorları kontrol edebilir, Lidar verisini işleyebilir veya kameradan görüntü alabilir.
- Haberleşme: Aynı veya farklı paketlerdeki diğer node'larla veri alışverişi yapabilir.
- Yazılım Mimarisi: Düğümler, kodun yönetilebilir olması için Nesne Yönelimli Programlama (OOP) kullanılarak, yani Class (Sınıf) yapısı ile oluşturulmalıdır.

1.3. DERLEME (BUILD) VE ORTAM KURULUMU
------------------------------------
Bir paket veya kod değiştiğinde çalışma alanının (workspace) derlenmesi gerekir.

Temel Derleme:
Sadece üzerinde çalıştığımız paketi derlemek zaman kazandırır:
    colcon build --packages-select simple_py_pkg

Geliştirici Modu (Symlink) ile Derleme:
Python dosyalarında yapılan değişikliklerde sürekli derleme yapmamak için sembolik bağ (symlink) kullanılır:
    colcon build --packages-select simple_py_pkg --symlink-install

Source (Kaynak) Sorunu ve Çözümü:
Derleme sonrası "source install/setup.bash" yapılmazsa ROS 2 paketi göremez. Her terminal açılışında bunu otomatikleştirmek için kalıcı çözüm:
    echo "source ~/ARTEK/ROS2/ros2_ws/install/setup.bash" >> ~/.bashrc
    source ~/.bashrc

1.4. NODE ÇALIŞTIRMA VE KOMUT SATIRI İŞLEMLERİ
--------------------------------------------
Oluşturulan node'u çalıştırmak için:
    ros2 run simple_py_pkg counter_node

Node Bilgilerini Görme:
- ros2 node list: Şu an aktif olan (çalışan) node'ları listeler.
- ros2 node info /counter_node: Belirtilen node hakkındaki yayıncı (publisher), abone (subscriber) ve servis bilgilerini gösterir. (Node çalışıyor olmalıdır)

Node İsmi Değiştirme (Remapping):
Aynı koddan birden fazla node çalıştırmak istendiğinde isim çakışmasını önlemek için çalışma anında isim değiştirilebilir:
    ros2 run simple_py_pkg counter_node --ros-args --remap __node:=yeni_node_ismi

1.5. ANALİZ VE SİMÜLASYON ARAÇLARI
--------------------------------
RQT (Görsel Analiz):
Terminalden "rqt" yazılarak açılan GUI ile node'ların bağlantıları ve sistemin genel durumu görsel olarak analiz edilebilir.

Turtlesim (Örnek Uygulama):
Basit kaplumbağa simülatörü.

- Kurulum:
    sudo apt install ros-humble-turtlesim

- Simülasyonu Başlatma:
    ros2 run turtlesim turtlesim_node

- Klavye Kontrolü (Teleop):
    (Farklı bir terminalde)
    ros2 run turtlesim turtle_teleop_key



# 2 KONULAR (TOPICS) VE HABERLEŞME

### 1\ Temel Mantık: Publisher & Subscriber

ROS 2'de nodelar birbirleriyle **Topic (Konu)** adı verilen kanallar üzerinden haberleşir. Bu yapı **Many-to-Many (Çoktan Çoğa)** iletişime izin verir; yani bir konuya birden fazla kişi abone olabilir veya yayın yapabilir.

  * **Publisher (Yayıncı):** Veriyi üreten ve belirli bir topic ismiyle (örneğin `/kamera_goruntusu`) sisteme salan düğümdür.
  * **Subscriber (Abone/Dinleyici):** İlgili topic ismine kaydolan ve o topic üzerinden gelen veriyi alıp işleyen düğümdür.

### 2\. Haberleşme Senaryoları (Kim Önce Başlarsa Ne Olur?)

Sorduğun kritik sorunun cevabı şudur:

  * **Önce Publisher Çalışırsa:** Yayıncı veriyi yayınlamaya başlar (örneğin radyoda yayın yapmak gibi). Eğer o an dinleyen (Subscriber) yoksa, veri **boşluğa gider ve kaybolur.**
  * **Önce Subscriber Çalışırsa:** Abone düğümü açılır ve "Ben `/topic` isimli kanalı dinliyorum" der. Ancak yayıncı henüz açılmadığı için **bekleme modunda kalır.** Yayıncı devreye girdiği anda verileri almaya başlar.
  * **Bağlantı Şartı:** İki düğümün konuşabilmesi için **Topic İsimlerinin** VE **Veri Tiplerinin (Message Type)** birebir aynı olması gerekir.

-----

### 3\. Uygulama ve Komutlar

**Yayıncıyı Başlatma:**
Kendi yazdığımız paketteki yayıncı node'u başlatırız:

ros2 run simple_py_pkg channel_node

**Veriyi Manuel Dinleme (Terminalden):**
Node çalışırken verinin gerçekten akıp akmadığını görmek için abone kodu yazmadan önce terminalden kontrol ederiz:

ros2 topic echo /channel_something

*(Not: `/channel_something` burada kodun içinde belirlenen topic ismidir.)*


### 4\. Turtlesim ile Topic ve Mesaj Analizi

Turtlesim simülasyonunda robotun hareket etmesini sağlayan mesaj tiplerini anlamak için kullandığımız komutların detayları şöyledir:

**A. Mesajın Yapısını Görmek:**
Robotlar genellikle `geometry_msgs` (geometri mesajları) kullanır. `Twist` mesajı robotun hız komutudur.

ros2 interface show geometry_msgs/msg/Twist

*Bu komutun çıktısı bize mesajın iç yapısını gösterir:*

  * **Vector3 linear:** Çizgisel Hız (x: ileri/geri, y: sağ/sol, z: yukarı/aşağı)
  * **Vector3 angular:** Açısal Hız (x, y, z eksenlerinde dönme)

**B. Alt Mesajı Görmek:**
Yukarıdaki `Twist` mesajının içinde `Vector3` diye bir veri tipi vardır. Onun ne olduğunu görmek için:

ros2 interface show geometry_msgs/msg/Vector3

*Çıktı:* `float64 x`, `float64 y`, `float64 z` (Koordinatların ondalıklı sayı olduğunu belirtir).

**C. Canlı Hız Verisini Dinlemek:**
Turtlesim'de kaplumbağayı klavyeyle sürerken, arka planda hangi hız verilerinin gönderildiğini canlı izlemek için:

ros2 topic echo /turtle1/cmd_vel

/turtle1/cmd_vel`:** Kaplumbağa 1'in hız komutlarını (Command Velocity) dinlediği topic ismidir. Sen tuşa bastığında bu topic üzerinden sayısal değerler akar.